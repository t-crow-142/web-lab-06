The database itself should be located in [the same directory as this file](.), in the file `lab-database.db`. When you clone this repo onto your machine, you must create the file yourself by following the steps in Exercise Zero. Once created, you may open this file in the SQLite DB Browser tool to examine its contents. The SQL script used to create the tables in this database is located in [`sql/lab-database.sql`](./sql/lab-database.sql).

Within the `modules` folder, `database.js` contains a simple module which connects to the database, and exports a *promise*. The `sqlite.open` function is `async`, because opening a database is an operation which may take some time. Later on in our code, when we want to *use* the database, we can `await` the promise that's been exported here, in order to wait until the database has been properly opened.

The `database.js` module is itself used within the `users-dao.js` module. This module contains all the code which interacts with the database. Our code, organized in this way, follows the *Data Access Object (DAO)* pattern. The database access code is contained within a small subset of the program (in this case, just the `users-dao` module). The rest of our application doesn't need to worry about SQL at all - it just interacts with the database through these DAO modules. **It is highly recommended that you follow this pattern for your final project**.

Within the `users-dao` module, we can see several functions which *create*, *retrieve*, *update*, and *delete* (CRUD) users from the database. As we can see, each of the `users-dao` functions is `async`. This is because any operation which interacts with the database is also `async` (we can see many examples of `await`ing these operations within the code).

Within this module, we can see different ways in which we can interact with the database from our JavaScript code:

- `db.run()` is used for SQL statements that don't return data from the database, such as `INSERT`, `UPDATE` and `DELETE` statements. For example:

  ```js
  await db.run(SQL`
    delete from users
    where id = ${id}`);
  ```

- `db.get()` and `db.all()` are used to obtain the results of `SELECT` statements.
  - `db.get()` returns just the first row of the result
  - `db.all()` returns all rows

  For example:
  ```js
  const users = await db.all(SQL`select * from users`);
  ```

- If we `INSERT` a row using `db.run()`, and that insert operation automatically generated a primary key value (for example, inserting a new user, specifying their name, username and password but not their id, will result in the id being generated by the database), we can access the generated id value using the `lastID` property of the result. For example:

  ```js
  const result = await db.run(SQL`
    insert into users (username, password, name)
    values(${user.username}, ${user.password}, ${user.name})`);

  // Get the auto-generated ID value.
  const id = result.lastID;
  ```

- If we need to supply data to the SQL, we can do so with JavaScript template literals. However, we're using the `sql-template-strings` template literals rather than the default ones - these will automatically add various ' ', and other *escape sequences*, as necessary. To do this, we have `require`d the package at the top of the file as follows:

  ```js
  const SQL = require("sql-template-strings");
  ```
  Then, we use it by prepending our template literals with `SQL`, e.g:

  ```js
  await db.run(SQL`delete from users where id = ${id}`);
  ```

The `users-dao` module is used currently within the `auth-middleware.js` middleware, and the `auth-routes.js` route handler. We're using, for example, its `retrieveUserWithAuthToken()` function on line `4` of `auth-middleware.js`. As can be seen, that function is `async`, which means if we want to `await` its result, we also need to make our function `async` (as we have done).